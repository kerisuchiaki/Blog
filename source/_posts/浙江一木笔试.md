---
title: 浙江一木笔试
date: 2024-12-06 02:00:47
tags: 笔试
---

# 1.奇数位丢弃



对于一个由 0..n 的所有数按升序组成的序列，我们要进行一些筛选，每次我们丢弃去当前所有数字中第奇数位个的数。重复这一过程直到最后剩下一个数。请求出最后剩下的数字。 

  
 

  数据范围： 1≤n≤1000 1 \le n \le 1000 \ 1≤n≤1000 ，本题有多组输入
 



##### **输入描述:**

```
每组数据一行一个数字，为题目中的n(n小于等于1000)。
```





##### **输出描述:**

```
一行输出最后剩下的数字。
```

```c++
/*
为了解决这个问题，我们需要理解筛选过程以及它如何影响序列。让我们从一个例子开始，然后概括出模式。

考虑序列 \(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\)。在第一次筛选中，我们丢弃奇数位的数字，所以序列变为 \(1, 3, 5, 7, 9\)。在第二次筛选中，我们再次丢弃奇数位的数字，所以序列变为 \(3, 7\)。在第三次筛选中，我们丢弃奇数位的数字，所以序列变为 \(7\)。因此，最后剩下的数字是 \(7\)。

现在，让我们尝试概括这个过程。如果我们从序列 \(0, 1, 2, \ldots, n\) 开始，第一次筛选后，我们剩下的是序列 \(1, 3, 5, \ldots, n\) 如果 \(n\) 是奇数，或者 \(1, 3, 5, \ldots, n-1\) 如果 \(n\) 是偶数。这相当于序列 \(2k-1\) 对于 \(k = 1, 2, \ldots, \lceil \frac{n+1}{2} \rceil\)。

在第二次筛选中，我们再次丢弃奇数位的数字，所以我们剩下的是序列 \(3, 7, 11, \ldots\)，这是序列 \(4k-1\) 对于 \(k = 1, 2, \ldots, \lceil \frac{\lceil \frac{n+1}{2} \rceil + 1}{2} \rceil\)。

我们可以看到，每次筛选都会使序列的长度减半，并且剩下的数字是形式为 \(2^m k - 1\) 的，其中 \(m\) 是筛选的次数。这个过程一直持续到序列中只剩下一个数字。

为了找到最后剩下的数字，我们需要确定筛选的次数，这相当于找到最小的 \(m\) 使得 \(2^m > n\)。最后剩下的数字将是 \(2^m - 1\)。

让我们用一个例子来验证这一点。如果 \(n = 10\)，最小的 \(m\) 使得 \(2^m > 10\) 是 \(4\)（因为 \(2^4 = 16 > 10\)）。因此，最后剩下的数字是 \(2^4 - 1 = 15 - 1 = 7\)，这与我们之前的例子相符。

因此，最后剩下的数字是 \(\boxed{2^{\lceil \log_2 (n+1) \rceil} - 1}\)。 ---ai还是有点牛逼的，直接给出了用数学规律的解释
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int n;
	while (cin >> n) {
		int k = 0;
		while (pow(2, k) <= n + 1) {
			k++;
		}
		cout << pow(2, k - 1) - 1 << endl;
	}
}


*/

#include <bits/stdc++.h>
#include <vector>
using namespace std;
int main()
{
    string s;
    while(getline(cin,s))
 {   int n=stoi(s);
    int len = n;
    vector<int> a(n + 1, 0);
    for (int i = 0; i < a.size(); i++)
        a[i] = i;
    while (a.size() > 1)
    {
        for (int i = 0; i < a.size(); i++)
        {
            if ((i + 1) % 2)
            {
                a[i] = -1;
            };
        };
        while (1)
        {
            vector<int>::iterator it = a.begin();
            while (it != a.end() && (*it) != -1)
            {
                it++;
            };
            if (it == a.end())
                break;
            a.erase(it);
        };
    };
    cout << a[0]<<"\n";
    }
}

/*最后提交的版本
#include <bits/stdc++.h>//类似为约瑟夫环，直接模拟也能过，但是犯的错误也太多了
using namespace std;
int main()
{
    string s;
    while(getline(cin,s)){//这是题目问题没说清楚，我还以为只有一行

    int n=stoi(s);
    vector<int> a(n + 1, 0);
    for (int i = 0; i < a.size(); i++)
        a[i] = i;
    int len = a.size();
    while (len > 1)
    {
        int idx = 0;
        for (int i = 0; i < a.size(); i++)
        {
            if (a[i] != -1)
            {
                if (idx % 2==0)//都从零开始了，还以为是奇数位淘汰，正确是偶数位
                    a[i] = -1, len--;
                idx++;
            };
        };
    };
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] != -1)
        {
            cout <<a[i]<<"\n";
            break;
        }
    };
    };
    return 0;
}
*/
```

# 2.反转链表

## 没啥好说的，写好多次了

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* last=head;
        ListNode* next=head;
        while(head){
            next=head->next;
            head->next=last;
            last=head;
            head=next;
        };
        return last;
    }
};
```





# 3.长度不超过n*n，且包含子序列“us”的、只由小写字母构成的字符串有多少个？ 答案对109+7109+7取模。

所谓子序列，指一个字符串删除部分字符（也可以不删）得到的字符串。

例如，"unoacscc"包含子序列"us"，但"scscucu"则不包含子序列"us"

#### 题解

定义dp\[i][j]为长度为i的字符串中包含us的数量，j=0表示不包含u,j=1表示包含u不包含s（考虑只包含s没有意义）,j=2表示包含us,那么状态转移方程

```c++
dp[i][0]=dp[i-1][0]*25;
dp[i][1]=dp[i-1][1]*25+dp[i-1][0];
dp[i][2]=dp[i-1][1]+dp[i-1][2]*26;
```



```c++
#include <bits/stdc++.h>//二维dp实现，dp[i][0]为含有u的串，dp[i][1]为含有s的串，dp[i][2]含有us的串,思路真妙啊
using namespace std;
const int p = 1e9+7;
int main()
{
    int n;
    cin>>n;
    vector<vector<long long>>dp(n+1,vector<long long>(3,1));
    long long ans=0;
    dp[1][0]=25;dp[1][1]=1;dp[1][2]=0;
    for(int i=2;i<=n;i++){
        dp[i][0]=(dp[i-1][0]*25)%p;
        dp[i][1]=(dp[i-1][1]*25+dp[i-1][0])%p;
        dp[i][2]=(dp[i-1][1]+dp[i-1][2]*26)%p;
        ans=(ans+dp[i][2])%p;
    };
    cout<<ans;
    return 0;
}
```

