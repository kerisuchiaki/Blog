---
title: 算法设计与分析实验三-动态规划
date: 2024-05-01 14:06:06
tags: 实验3
---

### 实验项目：分治法的应用

#### 实验目的

掌握动态规划算法的应用。

#### 一、实验内容

1. **最大子段和问题**：给定由n个整数组成的序列，求其连续子段的最大和。
2. **矩阵连乘问题**：给定n个矩阵{A1, A2, …, An}，求最佳计算次序以最小化数乘次数。
3. **双核CPU任务调度问题**：给定n个任务及其处理时长，设计调度方案使CPU处理完所有任务所需时间最短。

#### 二、问题分析

<!-- more -->

1. **最大子段和问题**：使用动态规划方法，状态转移方程为dp[i] = max(dp[i-1] + a[i], a[i])。
2. **矩阵连乘问题**：使用动态规划方法，状态转移方程为dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j])。
3. **双核CPU任务调度问题**：转化为01背包问题，状态转移方程为dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + a[i])。

#### 三、数据结构定义

1. **最大子段和问题**：Int dp[i] // 以a[i]结尾的子段和
2. **矩阵连乘问题**：Int dp[i][j] // A[i:j]的最少乘次
3. **双核CPU任务调度问题**：Int dp[i][j] // 前i个任务分配给两个处理器后，处理器1的处理量

#### 四、算法伪代码描述

1. **最大子段和问题**：

```
Copy CodemaxSum = currentSum = a[0]
for i from 1 to n-1:
    currentSum = max(currentSum + a[i], a[i])
    maxSum = max(maxSum, currentSum)
return maxSum
```

1. **矩阵连乘问题**：

```
Copy Codefor L from 2 to n:
    for i from 1 to n-L+1:
        j = i+L-1
        dp[i][j] = INF
        for k from i to j-1:
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j])
return dp[1][n]
```

1. **双核处理问题**：

```
Copy Codev = sum / 2
for i from 1 to n:
    for j from 1 to v:
        if a[i] > j:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i]] + a[i])
return 1024 * (sum - dp[n][v])
```

#### 五、算法时间和空间复杂度分析

1. **最大子段和问题**：时间复杂度O(n)，空间复杂度O(n)。
2. **矩阵连乘问题**：时间复杂度O(n^3)，空间复杂度O(n^2)。
3. **双核CPU任务处理问题**：时间复杂度O(n^2)，空间复杂度O(n^2)。

#### 六、错误记录和解决

1. **双核处理问题**：最初尝试贪心策略，未找到全局最优解，改用动态规划解决。
