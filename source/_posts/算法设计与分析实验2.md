---
title: 算法设计与分析实验2
date: 2024-04-14 19:48:53
tags: 实验
---

| ***\*实验项目\**** | 分治法的应用           | ***\*指导老师\**** |      |
| ------------------ | ---------------------- | ------------------ | ---- |
| ***\*实验目的\**** | 学习分治法的思想和应用 |                    |      |

## 一、实验内容

1.某石油公司有n口油井，为方便输送石油，计划修建输油管道。根据设计要求，水平方向有一条主管道，每口油井修一条垂直方向的支线管道通向主管道。请设计一种算法确定主管道的位置，使得所有油井到主管道之间的支线管道长度的总和最小

2.Karatsuba乘法用于实现两个大整数相乘。所谓大整数相乘是指整数比较大，相乘的结果超出了基本数据类型的表示范围，所以不能直接做乘法运算。算法的基本原理是将大整数拆分成两段后变成较小的整数，请设计分治算法说明Karatsuba乘法的原理，并实现该算法。

## 二、问题分析

### 1.铺设油井管道

这个显然是将管道铺在中间最合适，因为极端情况管道在最上方和最下方都会使得距离很大，那么管道的位置也显然之能是所有油井的中间位置，那么问题就转换为求所有的油井的中位数了，我们可以先进行排序然后在取中间值，但是由于排序算法的时间复杂度最快也是O(ologn)，这不满足题目要求，要使用O(n)的算法，我们可以使用分治策略求解，具体就是快速选择算法，它可以让我们在O(n）的时间内选出第k大的数。
### 2.Karatsuba乘法

由karartsuba算法的原理我们知道，对于竖式乘法，如果把数分成两部分分别相乘，那么会进行4次乘法，三次加法，而使用Karatsuba算法,可以减少一次乘法，7次加法，这使得大数乘法的时间可以得到优化，我们可以使用分治法来实现这个算法，即进行两个大数的乘法，可以转换为三次小的乘法和一些加法来完成，然后递归进行即可

<!-- more -->

## 三、数据结构定义

### 1.铺设油井管道

Int arr[n];//所有油井的距离
Int median;//油井距离的中位数
Int minx;//距离总和最小值
int quickSelect（int a[],int left,int right)//寻找数组 arr 中第 k 小的元素

### 3.karatsuba算法

string  karatsuba(string a,string b)//karatsuba算法，计算两个大数的乘积以字符串保存结果
string operator+(const string& num1, const string& num2)；//重载运算符进行大数加法
string operator-(const string& num1, const string& num2)；//重载运算符进行两个大数的减法



## 四、算法伪代码描述

### 1.铺设油井管道


```python
函数 quickSelect(arr, left, right, k):
    如果 left 等于 right，则返回 arr[left]
// 分治法的思想：将数组分成两部分，对其中一部分进行处理
// 选取中枢元素
pivotIndex = left + (right - left) / 2
pivot = arr[pivotIndex]

// 将中枢元素移动到数组末尾
交换 arr[pivotIndex] 和 arr[right]

// 分区过程
i = left
对于 j 从 left 到 right - 1：
    如果 arr[j] < pivot：
        交换 arr[i] 和 arr[j]
        i++

交换 arr[i] 和 arr[right]

// 判断中枢元素的位置与 k 的大小关系
如果 i 等于 k，则返回 arr[i]
否则如果 i 小于 k，则递归调用 quickSelect(arr, i + 1, right, k)
否则递归调用 quickSelect(arr, left, i - 1, k)
函数 findMedian(arr, n):
    返回 quickSelect(arr, 0, n - 1, n / 2)

主函数：
    输入 n
    分配数组 arr 大小为 n
    对于 i 从 0 到 n - 1：
        输入 a 和 b
        将 b 放入 arr[i]
        median = findMedian(arr, n)
	minx = 0
	对于 i 从 0 到 n - 1：
    minx += abs(median - arr[i])

    输出 minx
    释放数组 arr
```


​    


### 2.karatsuba算法

```python
// 定义大数加法
string operator+(const string& num1, const string& num2) {
    string result; // 存储结果
    int carry = 0; // 进位

    // 从低位到高位逐位相加
    int i = num1.size() - 1;
    int j = num2.size() - 1;
    while (i >= 0 || j >= 0 || carry > 0) {
        int sum = carry; // 当前位的和等于进位
        if (i >= 0) {

// 将字符转换为数字并加到当前位的和中
            sum += num1[i] - '0';i--;
        }
        if (j >= 0) {
// 将字符转换为数字并加到当前位的和中
            sum += num2[j] - '0';j--;
        }
        

        // 更新进位和当前位的值
        carry = sum / 10; // 计算进位
        sum %= 10; // 更新当前位的值

// 将当前位的值转换为字符并添加到结果中
        result += to_string(sum);     }

    // 反转结果字符串，得到正确的加法结果
    reverse(result.begin(), result.end());
    return result;

}

// 定义大数减法
string operator-(const string& num1, const string& num2) {
    // 实现减法逻辑
}

// 定义 Karatsuba 算法
string karatsuba(string a, string b) {
    // 获取输入字符串的长度
    int n = a.size();
    int m = b.size();
    string ans = "0";
    

    // 如果输入的字符串长度为 1，则直接相乘
    if (n == 1) {
        // 实现直接相乘逻辑
    } else if (m == 1) {
        // 实现直接相乘逻辑
    }
    
    // 对输入字符串进行补零，使得两个字符串长度相等
    if (n > m) {
        // 实现补零逻辑
    } else if (n < m) {
        // 实现补零逻辑
    }
    
    // 分割输入字符串为两部分
    string a1 = a.substr(0, n / 2);
    string a2 = a.substr(n / 2, n - n / 2);
    string b1 = b.substr(0, m / 2);
    string b2 = b.substr(m / 2, m - m / 2);
    
    // 递归调用 Karatsuba 算法
    string a1b1 = karatsuba(a1, b1);
    string a2b2 = karatsuba(a2, b2);
    string a1a2 = a1 + a2;
    string b1b2 = b1 + b2;
    string a1a2b1b2 = karatsuba(a1a2, b1b2);
    
    // 使用分治法思想计算乘积
    a1a2b1b2 = a1a2b1b2 - a1b1 - a2b2;
    for (int i = 0; i < 2 * (n - n / 2); i++) {
        a1b1 += '0';
    }
    for (int i = 0; i < (n - n / 2); i++) {
        a1a2b1b2 += '0';
    }
    ans = a1b1 + a1a2b1b2;
    ans = ans + a2b2;
    
    return ans;

}

// 主函数
int main() {
    // 输入两个大数
    string a, b;
    cin >> a;
    cin >> b;
    

    // 调用 Karatsuba 算法计算乘积
    string ans = karatsuba(a, b);
    
    // 去除结果前面的多余零，并输出结果
    while (ans[0] == '0') ans.erase(0, 1);
    cout << ans << endl;

}
```



## 五、算法时间和空间复杂度分析（要求写出详细过程）

### 1.铺设油井管道

由于我们采用的快速选择算法来进行分治处理，时间复杂度也就是快速选择算法的时间复杂度，快速选择算法，每次选择一个基元遍历整个数组分区后就可以判断，如果结果不是基元则递归判断比基元小的数据部分或则比基元数据大的部分，则可以得到递推式T(n)=T(n/2)+n，递推下去则得到
T(n)=T(n/2)+n=T(n/4)+n/2+n=T(1)+....+n/2+n=1+2+...n/2+n=1(1-2^t)/(1-2),其中t=log2n(2为底),最后得到T(n)=2n-1,即时间复杂度为O(n)=n;

### 2.karatsuba算法

karatsuba算法将两个数的乘法变成3个数的乘法和7次加法，显然递推式为T(n)=3T(n/2)+7=3^t+7t其中t=log2n(2为底),则T(n)=n^log23+7log23,即时间复杂度为O(n^log23)。

## 六、错误记录和解决

1.对于油井管道铺设问题，一开始使用c++的cin处理输入，但是总是超时，后来改成c语言时间就变短了
2.karatsuba算法，一开始想的是直接按照整数乘法使用数据范围更大的long long来模拟karatsuba算法，对于不是特别大的数字还能正确显示结果，后来我发现题目的输入数据远远超过long long的范围，并且这种做法不具有通用性，最后还是采用字符串保存结果

## 七、心得体会

分治算法是基础算法，它可以帮助我们有效分析问题，并分治处理，使得我们不用关心所有细节，这一点和递归很相似，尽管分治法很多时候都是用递归实现。
