---
title: 我的算法小抄
date: 2024-10-09 22:37:54
tags: 算法
---

# 输入输出

## 读取一行

c:

```c
char s[200];//确保s够大
gets(s);
```

c++:

```c++
string s;
getline(cin,s);//或cin.getline(s,100);后一个参数是读取大小
```



tps:有时候记得读入换行

## 读入字符串转数字

```c++
string s;getline(cin,s);
stringstream ss(s)
vector<int> nums;
while(ss>>num){
    nums.push_back(num);
};
```

<!-- more -->

# 遍历

以map为例子

## 迭代器遍历

```c++
map<int,int>:: iterator it=mp.begin();//迭代器类似指针
while(it!=mp.end()){
    cout<<it->first<<it->second;//cout<<*it;
    it++;
}
```

## for增强遍历

```c++
map<int,int> mp;
for(auto i:mp){//i是个结构体，也可以加引用
 	cout<<mp.first<<mp.second;
}
```

## map按索引遍历

1.使用advance();

```c++
map<int,int> ::iterator it=mp.begin();
advance(it,idx);//idx是想要访问的下标
cout<<*it;
```

2.使用next()

```c++
auto it=next(mp.begin(),idx);
cout<<*it;
```

map,set进行二叉搜索

## set求交并集

求交并差集：

```c++
set_intersection(a.begin(),a.end(),b.begin(),b.end(),,inserter( C1 , C1.begin());
set_union(A.begin(),A.end(),B.begin(),B.end(),inserter( C1 , C1.begin() ) );
set_difference(A.begin(),A.end(),B.begin(),B.end(),inserter( C1 , C1.begin() ) );
```

# 搜索

# 二分搜索

```c++
map<int,int> mp;
map<int,int> ::iterator it;
it=lower_bound(mp.begin(),mp.end(),val);
it=mp.lower_bound(val);
```

比较cmp

```c++
bool cmp(node a,node b){
    return a.first==b.first?a.second<b.second:a.first<b.first//结构体排序
}
```

# 易错提醒

## 1.当map超时时，试试unordered_map

## 2.函数传参要改变参数一定要用引用，我以为和java一样，对象或集合类型是可以修改的，结果不是

