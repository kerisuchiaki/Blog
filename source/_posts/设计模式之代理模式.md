---
title: java动态代理
date: 2024-02-29 23:19:43
tags: java源码
---

## 两种代理方式

Java 中的代理方式分为静态代理和动态代理，它们各有特点和适用场景。

### 静态代理

静态代理是在编译时就确定代理对象的方式，需要为每一个被代理类编写对应的代理类。以下是静态代理的代码示例：

<!-- more -->

```java
package org.example.jdk;

class Star{
    String name;
    int age;
    public String sing(){
        System.out.println("sing........");
        return "sing..";
    }
    public void dance(){
        System.out.println("dance.........");
    }
}
public class StaticProxyDemo {
    public static void main(String[] args) {
        Star star = new Star();
        StarProxy starProxy = new StarProxy(star);
        starProxy.sing();
        starProxy.dance();
    }
}
class StarProxy{
    StarProxy(Star star){
        this.star=star;
    }
    Star star;
    public String sing(){
        System.out.println("Enhancement before singing");
        String res=star.sing();
        System.out.println("Enhancement after singing");
        return res;
    }
    public void dance(){
        System.out.println("Enhancement before dancing");
        star.dance();
        System.out.println("Enhancement after dancing");
    }
}
```

### 动态代理

动态代理可以在运行时动态生成代理对象，主要有 JDK 动态代理和 CGLIB 代理两种方式。

#### JDK 动态代理

JDK 动态代理是基于接口的代理方式，被代理对象必须实现接口。它的原理是通过反射机制在运行时动态生成代理类。在 JDK 动态代理中，核心接口是 InvocationHandler，用于处理代理实例并返回结果。以下是 JDK 动态代理的简单示例代码：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Star {
    String sing();
    void dance();
}

class RealStar implements Star {
    @Override
    public String sing() {
        System.out.println("Real star is singing...");
        return "sing..";
    }

    @Override
    public void dance() {
        System.out.println("Real star is dancing...");
    }
}

class StarHandler implements InvocationHandler {
    private Star realStar;

    public StarHandler(Star realStar) {
        this.realStar = realStar;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Enhancement before method execution");
        Object result = method.invoke(realStar, args);
        System.out.println("Enhancement after method execution");
        return result;
    }
}

public class DynamicProxyDemo {
    public static void main(String[] args) {
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);

        Star proxy = (Star) Proxy.newProxyInstance(
                realStar.getClass().getClassLoader(),
                realStar.getClass().getInterfaces(),
                handler
        );

        proxy.sing();
        proxy.dance();
    }
}
```

#### CGLIB 代理

CGLIB 代理是基于继承的代理方式，不要求被代理对象实现接口，能够代理类而非接口。它的原理是通过字节码增强技术动态生成子类来实现代理。使用 CGLIB 代理时，被代理类无需实现接口。你可以参考以下示例了解 CGLIB 代理的基本用法。

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

class RealStar {
    public void sing() {
        System.out.println("Real star is singing...");
    }

    public void dance() {
        System.out.println("Real star is dancing...");
    }
}

class StarInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Enhancement before method execution");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("Enhancement after method execution");
        return result;
    }
}

public class CglibProxyDemo {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(RealStar.class);
        enhancer.setCallback(new StarInterceptor());

        RealStar proxy = (RealStar) enhancer.create();
        proxy.sing();
        proxy.dance();
    }
}
```