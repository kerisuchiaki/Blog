<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>易联众面试总结 | hatena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.面试问答1.1程序是怎么跑起来的当面试官问到“程序是怎么跑起来的”，他们通常想了解你对程序执行过程的基本理解，包括操作系统、编译过程、程序运行时的内存管理等方面。以下是一个结构化的回答：               详情                    源代码编写： 首先，开发者使用编程语言（如C、Java、Python等）编写源代码。   编译过程： 源代码需要通过编译器转换成机器语言">
<meta property="og:type" content="article">
<meta property="og:title" content="易联众面试总结">
<meta property="og:url" content="https://kerisuchiaki.github.io/2024/09/02/%E6%98%93%E8%81%94%E4%BC%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="hatena">
<meta property="og:description" content="1.面试问答1.1程序是怎么跑起来的当面试官问到“程序是怎么跑起来的”，他们通常想了解你对程序执行过程的基本理解，包括操作系统、编译过程、程序运行时的内存管理等方面。以下是一个结构化的回答：               详情                    源代码编写： 首先，开发者使用编程语言（如C、Java、Python等）编写源代码。   编译过程： 源代码需要通过编译器转换成机器语言">
<meta property="og:locale" content="zn_CN">
<meta property="article:published_time" content="2024-09-02T08:51:04.000Z">
<meta property="article:modified_time" content="2024-10-05T09:17:53.495Z">
<meta property="article:author" content="myself">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/Blog/atom.xml" title="hatena" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/Blog/css/style.css">

  
    
<link rel="stylesheet" href="/Blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Blog/" id="logo">hatena</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/Blog/">Home</a>
        
          <a class="main-nav-link" href="/Blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/Blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kerisuchiaki.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-易联众面试总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Blog/2024/09/02/%E6%98%93%E8%81%94%E4%BC%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2024-09-02T08:51:04.000Z" itemprop="datePublished">2024-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      易联众面试总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-面试问答"><a href="#1-面试问答" class="headerlink" title="1.面试问答"></a>1.面试问答</h1><h2 id="1-1程序是怎么跑起来的"><a href="#1-1程序是怎么跑起来的" class="headerlink" title="1.1程序是怎么跑起来的"></a>1.1程序是怎么跑起来的</h2><p>当面试官问到“程序是怎么跑起来的”，他们通常想了解你对程序执行过程的基本理解，包括操作系统、编译过程、程序运行时的内存管理等方面。以下是一个结构化的回答：</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        详情
    </div>
    <div class='fold-content'>
        <ol>
<li><strong>源代码编写</strong>：<ul>
<li>首先，开发者使用编程语言（如C、Java、Python等）编写源代码。</li>
</ul>
</li>
<li><strong>编译过程</strong>：<ul>
<li>源代码需要通过编译器转换成机器语言。编译器会进行词法分析、语法分析、语义分析、优化以及代码生成等步骤。</li>
<li>对于解释型语言，如Python或JavaScript，源代码在运行时由解释器逐行解释执行。</li>
</ul>
</li>
<li><strong>链接过程</strong>：<ul>
<li>如果程序由多个源文件组成，或者使用了库文件，链接器会将这些编译后的代码和库文件链接成最终的可执行文件。</li>
</ul>
</li>
<li><strong>加载到内存</strong>：<ul>
<li>操作系统加载可执行文件到内存中。这通常涉及加载代码段、数据段和堆栈等。</li>
<li><span id="more"></span></li>
</ul>
</li>
<li><strong>程序执行</strong>：<ul>
<li>程序开始执行，通常是从程序的入口点（如main函数）开始。</li>
<li>程序运行时，会使用CPU进行计算，访问内存进行数据存储和读取，可能还会进行I&#x2F;O操作。</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li>程序运行过程中，操作系统负责内存管理，包括分配和回收内存，处理内存访问冲突等。</li>
<li>某些语言（如C++和Java）有垃圾回收机制来自动管理内存。</li>
</ul>
</li>
<li><strong>程序终止</strong>：<ul>
<li>程序执行完成后，操作系统会负责清理分配的资源，包括内存、文件句柄、网络连接等。</li>
</ul>
</li>
<li><strong>错误处理</strong>：<ul>
<li>在程序运行过程中，操作系统和程序本身都会进行错误处理，确保异常情况能够得到妥善处理。</li>
</ul>
</li>
<li><strong>用户交互</strong>：<ul>
<li>许多程序会与用户进行交互，接收输入并提供输出。</li>
</ul>
</li>
<li><strong>多任务处理</strong>：<ul>
<li>现代操作系统支持多任务处理，允许多个程序同时运行。</li>
</ul>
</li>
</ol>
<p>这个回答展示了你对程序从编写到执行的整个过程的理解，同时也显示了你对操作系统和编程语言特性的知识。根据面试官的反馈，你可以进一步深入讨论某些部分，比如编译器的工作原理、内存管理的细节，或者是并发和多线程的处理。</p>

    </div>
</div>

<h2 id="1-2对于Java中基础类型的内存分布及运行过程，你能具体说明一下吗？"><a href="#1-2对于Java中基础类型的内存分布及运行过程，你能具体说明一下吗？" class="headerlink" title="1.2对于Java中基础类型的内存分布及运行过程，你能具体说明一下吗？"></a>1.2对于Java中基础类型的内存分布及运行过程，你能具体说明一下吗？</h2><p>你知道java程序在java内存中是怎么表现的吗？举个很简单的例子，我现在写了一个类，类里面有个主函数。主函数里面定义了两个变量，一个A一个B，A等于1，B等于2。我做了一个print输出，A加B，那请问一下它在内存中是怎么表现的，经过哪些步骤？你这有了解过吗？(面试官可能想要的答案是要回答栈帧的生命周期) </p>
<div class='fold collapsed'>
    <div class='fold-title'>
        答案
    </div>
    <div class='fold-content'>
        <ol>
<li><p><strong>编写源代码</strong>： 首先，你编写了一个Java类，其中包含一个主函数（<code>main</code> 方法），在该方法中定义了两个变量 <code>A</code> 和 <code>B</code>，并分别赋值为1和2。</p>
<p> java</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(A + B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译源代码</strong>： 使用Java编译器（<code>javac</code>）将源代码编译成字节码（<code>.class</code> 文件）。</p>
<p> sh</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SimpleProgram.java</span><br></pre></td></tr></table></figure>

<p> 这会生成一个名为 <code>SimpleProgram.class</code> 的文件。</p>
</li>
<li><p><strong>类加载</strong>： 当程序运行时，Java虚拟机（JVM）的类加载器负责加载字节码文件。类加载器会将 <code>SimpleProgram.class</code> 文件加载到内存中。</p>
</li>
<li><p><strong>内存分配</strong>： JVM为程序分配内存，主要包括以下几个部分：</p>
<ul>
<li><strong>堆（Heap）</strong>：存储对象实例和数组。</li>
<li><strong>方法区（Method Area）</strong>：存储类的结构，如字段、方法、代码等。</li>
<li><strong>栈（Stack）</strong>：存储局部变量、操作数栈、方法调用等。</li>
</ul>
</li>
<li><p><strong>程序执行</strong>： 程序开始执行，具体步骤如下：</p>
<p> a. <strong>方法调用</strong>：</p>
<ul>
<li>当 <code>main</code> 方法被调用时，JVM会为该方法创建一个新的栈帧（Stack Frame）。</li>
</ul>
<p> b. <strong>局部变量表</strong>：</p>
<ul>
<li>在栈帧中，会创建一个局部变量表，用于存储方法中的局部变量。</li>
<li><code>A</code> 和 <code>B</code> 被定义为 <code>int</code> 类型，每个变量占用4个字节（32位）的内存空间。</li>
</ul>
<p> c. <strong>变量赋值</strong>：</p>
<ul>
<li>将 <code>A</code> 赋值为1，<code>B</code> 赋值为2。</li>
</ul>
<p> d. <strong>计算和输出</strong>：</p>
<ul>
<li>计算 <code>A + B</code> 的结果，并将结果压入操作数栈。</li>
<li>调用 <code>System.out.println</code> 方法，将结果输出到控制台。</li>
</ul>
</li>
<li><p><strong>内存回收</strong>： 当 <code>main</code> 方法执行完成后，局部变量表和栈帧会被销毁，相关内存会被回收。</p>
</li>
</ol>
<h3 id="内存布局示例"><a href="#内存布局示例" class="headerlink" title="内存布局示例"></a>内存布局示例</h3><p>假设 <code>main</code> 方法的栈帧如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------|</span><br><span class="line">| 返回地址                  |</span><br><span class="line">|---------------------------|</span><br><span class="line">| 局部变量表                |</span><br><span class="line">|   A (int): 1              |</span><br><span class="line">|   B (int): 2              |</span><br><span class="line">|---------------------------|</span><br><span class="line">| 操作数栈                  |</span><br><span class="line">|   3 (A + B 的结果)        |</span><br><span class="line">|---------------------------|</span><br><span class="line">| 其他信息                  |</span><br><span class="line">|---------------------------|</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>编写源代码</strong>：定义类和方法，赋值变量。</li>
<li><strong>编译源代码</strong>：生成字节码文件。</li>
<li><strong>类加载</strong>：JVM加载字节码文件。</li>
<li><strong>内存分配</strong>：为程序分配内存，包括堆、方法区和栈。</li>
<li><strong>程序执行</strong>：方法调用，局部变量表创建，变量赋值，计算和输出。</li>
<li><strong>内存回收</strong>：方法执行完成后，释放内存。</li>
</ol>
<p>​      </p>

    </div>
</div>

<h2 id="1-3关于JDK-jdk1-7相较于1-8有哪些更新"><a href="#1-3关于JDK-jdk1-7相较于1-8有哪些更新" class="headerlink" title="1.3关于JDK,jdk1.7相较于1.8有哪些更新"></a>1.3关于JDK,jdk1.7相较于1.8有哪些更新</h2><p>1.首先是方法区和运行时常量池在1.7中被放入了堆当中，到了1.8改为放入到直接内存中</p>
<p>2.方法区只是JVM规范中的概念，不同的虚拟机可以有不同的实现，1.7中方法区的具体实现叫做永久代，1.8后变为元空间</p>
<h2 id="1-4c语言的内存模型和java的内存模型有什么区别"><a href="#1-4c语言的内存模型和java的内存模型有什么区别" class="headerlink" title="1.4c语言的内存模型和java的内存模型有什么区别?"></a>1.4c语言的内存模型和java的内存模型有什么区别?</h2><p>内存模型差异：c语言的内存分布主要是代码段，数据段，堆，栈，而java的内存模型主要是有线程共享的堆，字符串常量池，线程私有的栈，程序计数器，本地方法栈，虚拟机栈，还有本地内存中的运行时常量池，方法区</p>
<p>内存特点差异：C语言的堆内存不能自动管理，即需要手动释放和申请，而java可以由jvm自动管理</p>
<h2 id="1-5Spring中的IOC（依赖注入）是如何工作的？"><a href="#1-5Spring中的IOC（依赖注入）是如何工作的？" class="headerlink" title="1.5Spring中的IOC（依赖注入）是如何工作的？"></a>1.5Spring中的IOC（依赖注入）是如何工作的？</h2><p>讲讲Spring IOC的过程，讲讲Springboot自动转配的过程</p>
<h3 id="Spring-IOC-过程"><a href="#Spring-IOC-过程" class="headerlink" title="Spring IOC 过程"></a>Spring IOC 过程</h3><ol>
<li><strong>加载配置</strong>：Spring 通过 XML、注解或 Java 配置类加载 Bean 的定义。</li>
<li><strong>创建 Bean</strong>：根据定义创建 Bean 实例。</li>
<li><strong>属性赋值</strong>：注入依赖的 Bean 或配置的值。</li>
<li><strong>初始化</strong>：调用 Bean 的初始化方法。</li>
</ol>
<h3 id="Spring-Boot-自动配置过程"><a href="#Spring-Boot-自动配置过程" class="headerlink" title="Spring Boot 自动配置过程"></a>Spring Boot 自动配置过程</h3><ol>
<li><strong>启动类</strong>：使用 <code>@SpringBootApplication</code> 注解启动应用。</li>
<li><strong>自动配置</strong>：Spring Boot 根据添加的 Starter 和类路径下的库自动配置 Bean。</li>
<li><strong>条件注解</strong>：如 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingBean</code> 等，控制配置的激活。</li>
<li><strong>自定义配置</strong>：通过 <code>application.properties</code> 或 <code>application.yml</code> 调整自动配置的默认值。</li>
</ol>
<h2 id="1-5-1在了解Spring-Boot启动时的行为时，是否研究过Start类或相关starter模块？"><a href="#1-5-1在了解Spring-Boot启动时的行为时，是否研究过Start类或相关starter模块？" class="headerlink" title="1.5.1在了解Spring Boot启动时的行为时，是否研究过Start类或相关starter模块？"></a>1.5.1在了解Spring Boot启动时的行为时，是否研究过Start类或相关starter模块？</h2><p>Springboot在启动的时候肯定都会加载一个类，对吧？或者叫库，叫做SpringBoot-Start那你有了解过starter它里面做了哪些动作吗?</p>
<p>答：Spring Boot Starter 是一种方便的依赖管理方式，它包含了一系列库的集合，这些库通常是为了支持某项功能。当Spring Boot应用启动时，如果包含了某个Starter，那么与之相关的依赖就会被自动加载。Starter里面通常会进行以下动作：</p>
<ol>
<li><strong>自动配置</strong>：Starter中包含的自动配置类会根据classpath下的库和应用的配置文件自动配置Bean。</li>
<li><strong>依赖管理</strong>：Starter定义了一组合理的依赖版本，简化了Maven或Gradle的依赖配置。</li>
<li><strong>默认配置</strong>：提供默认的配置参数，这些参数可以在应用的配置文件中被覆盖。</li>
<li><strong>启动器自动配置</strong>：<code>spring-boot-starter</code> 通常包含一个或多个 <code>spring-boot-autoconfigure</code> 模块，这些模块负责检查classpath下的库并进行自动配置。</li>
<li><strong>元数据配置</strong>：通过 <code>META-INF/spring.factories</code> 文件指定自动配置类，Spring Boot在启动时会读取这些文件并加载配置。</li>
<li><strong>简化开发</strong>：开发者不需要深入了解底层配置细节，可以快速开始开发工作。</li>
</ol>
<div class='fold collapsed'>
    <div class='fold-title'>
        举例：
    </div>
    <div class='fold-content'>
        <p>以 <code>spring-boot-starter-web</code> 为例，这个Starter用于创建Web应用程序。下面是它在Spring Boot应用启动时的一些典型动作：</p>
<ol>
<li><strong>依赖引入</strong>：<ul>
<li>当你在项目的构建配置文件（如<code>pom.xml</code>）中添加了<code>spring-boot-starter-web</code>依赖，它会自动引入Spring MVC、Tomcat（或其他Servlet容器）、Spring Web以及其他相关的依赖库。</li>
</ul>
</li>
<li><strong>自动配置</strong>：<ul>
<li>应用启动时，<code>spring-boot-starter-web</code> 会触发相关的自动配置类，如<code>WebMvcAutoConfiguration</code>，它负责配置DispatcherServlet、ViewResolver、MessageConverters等。</li>
<li>嵌入式Tomcat服务器也会被自动配置，以便无需部署WAR文件即可运行应用。</li>
</ul>
</li>
<li><strong>默认配置</strong>：<ul>
<li>提供默认的MVC配置，如静态资源处理、欢迎页面、异常处理等。</li>
</ul>
</li>
<li><strong>条件注解</strong>：<ul>
<li>使用条件注解（如<code>@ConditionalOnMissingBean</code>）确保只在没有其他自定义配置的情况下才应用默认配置。</li>
</ul>
</li>
<li><strong>自定义配置</strong>：<ul>
<li>开发者可以在<code>application.properties</code>或<code>application.yml</code>中定义自己的配置，如服务器端口、静态资源路径等，这些配置会覆盖Starter的默认配置。</li>
</ul>
</li>
<li><strong>启动类</strong>：<ul>
<li>应用的入口通常是一个带有<code>@SpringBootApplication</code>注解的主类，这个注解包含了<code>@EnableAutoConfiguration</code>，允许Spring Boot根据添加的Starter进行自动配置。</li>
</ul>
</li>
<li><strong>Spring Boot应用上下文</strong>：<ul>
<li>所有自动配置的Bean都会被注册到Spring应用上下文中，使得开发者可以像使用其他Spring Bean一样使用它们。</li>
</ul>
</li>
</ol>
<p>通过<code>spring-boot-starter-web</code>，开发者可以快速搭建一个Web应用，而不需要关心底层的Servlet容器配置和MVC框架的搭建。这大大简化了Web应用的开发过程。</p>

    </div>
</div>

<div class='fold collapsed'>
    <div class='fold-title'>
        再举个例子：
    </div>
    <div class='fold-content'>
        <p><code>spring-boot-starter-jdbc</code> 是一个用于简化数据库操作的Spring Boot Starter。它提供了自动配置和依赖管理，使得开发者能够更容易地使用 JDBC 进行数据库编程。以下是它在Spring Boot应用启动时的一些典型动作：</p>
<ol>
<li><p><strong>依赖引入</strong>：</p>
<ul>
<li>当你在项目的构建配置文件（如<code>pom.xml</code>）中添加了<code>spring-boot-starter-jdbc</code>依赖，它会自动引入<code>spring-jdbc</code>、数据库连接池（如HikariCP）、JDBC API等必要的依赖库。</li>
</ul>
</li>
<li><p><strong>自动配置</strong>：</p>
<ul>
<li>应用启动时，<code>spring-boot-starter-jdbc</code> 会触发相关的自动配置类，如<code>DataSourceAutoConfiguration</code>，它负责配置数据源（DataSource）。</li>
<li>根据<code>application.properties</code>或<code>application.yml</code>中的配置，自动配置类会创建并配置数据库连接池。</li>
</ul>
</li>
<li><p><strong>默认配置</strong>：</p>
<ul>
<li>提供默认的数据库连接配置，如URL、用户名、密码等，这些默认值可以在应用的配置文件中被覆盖。</li>
</ul>
</li>
<li><p><strong>条件注解</strong>：</p>
<ul>
<li>使用条件注解（如<code>@ConditionalOnMissingBean</code>）确保只在没有其他自定义数据源配置的情况下才应用默认配置。</li>
</ul>
</li>
<li><p><strong>自定义配置</strong>：</p>
<ul>
<li>开发者可以在<code>application.properties</code>或<code>application.yml</code>中定义自己的数据库连接配置，如数据库URL、用户名、密码、连接池大小等。</li>
</ul>
</li>
<li><p><strong>数据源</strong>：</p>
<ul>
<li>应用会创建一个数据源 Bean，通常是连接池实现，如HikariCP，用于管理数据库连接。</li>
</ul>
</li>
<li><p><strong>JdbcTemplate</strong>：</p>
<ul>
<li>通常会配置一个<code>JdbcTemplate</code> Bean，它是一个简化JDBC操作的工具类，提供了执行SQL语句的便捷方法。</li>
</ul>
</li>
<li><p><strong>启动类</strong>：</p>
<ul>
<li>应用的入口通常是一个带有<code>@SpringBootApplication</code>注解的主类，这个注解包含了<code>@EnableAutoConfiguration</code>，允许Spring Boot根据添加的Starter进行自动配置。</li>
</ul>
</li>
<li><p><strong>Spring Boot应用上下文</strong>：</p>
<ul>
<li>所有自动配置的Bean，包括数据源和<code>JdbcTemplate</code>，都会被注册到Spring应用上下文中，使得开发者可以像使用其他Spring Bean一样使用它们。</li>
</ul>
</li>
</ol>
<p>通过<code>spring-boot-starter-jdbc</code>，开发者可以快速设置数据库连接和操作，而不需要手动配置数据源和JDBC模板。这使得数据库编程变得更加简单和高效。</p>

    </div>
</div>







<h2 id="1-6关于您的“精准营销抽奖服务平台”项目中，为何选择使用Redis的独占锁？"><a href="#1-6关于您的“精准营销抽奖服务平台”项目中，为何选择使用Redis的独占锁？" class="headerlink" title="1.6关于您的“精准营销抽奖服务平台”项目中，为何选择使用Redis的独占锁？"></a>1.6关于您的“精准营销抽奖服务平台”项目中，为何选择使用Redis的独占锁？</h2><p>问：我看你这个项目上面是有写一个精准营销的抽奖服务平台是吧？那你这边用到redis，然后数据库行锁转为了redis的独占锁。你当时我怎么会去考虑这种方法去解决的？然后当初是遇到什么问题才会采用这种方法去解决？</p>
<p>待定</p>
<h2 id="1-7能否解释一下如何通过自定义注解实现期望的功能？"><a href="#1-7能否解释一下如何通过自定义注解实现期望的功能？" class="headerlink" title="1.7能否解释一下如何通过自定义注解实现期望的功能？"></a>1.7能否解释一下如何通过自定义注解实现期望的功能？</h2><p>问：我现在想要自定义一个注解，我希望在他在其中的时候，就帮我做一点事情。有没有注解的这个逻辑，我希望在程序启动的时候，被我注解的方法然后自动运行。那这个方法里面，输出一些日志信息或者都无所谓，但是这个方法一定要被系统被程序给调用到</p>
<p>答：</p>
<p>1.定义注解</p>
<p>2.创建配置类</p>
<p>3.使用注解</p>
<p>4.启动springboot应用</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        具体一点
    </div>
    <div class='fold-content'>
        <p>在Spring框架中，你可以通过创建自定义注解并结合配置类来实现在程序启动时自动执行特定方法。以下是实现这一功能的基本步骤：</p>
<h3 id="1-定义自定义注解"><a href="#1-定义自定义注解" class="headerlink" title="1. 定义自定义注解"></a>1. 定义自定义注解</h3><p>首先，你需要定义一个自定义注解，例如<code>@RunAtStartup</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RunAtStartup &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>@Target(ElementType.METHOD)</code> 指定了注解可以用在方法上，<code>@Retention(RetentionPolicy.RUNTIME)</code> 表示注解在运行时可用。</p>
<h3 id="2-创建配置类"><a href="#2-创建配置类" class="headerlink" title="2. 创建配置类"></a>2. 创建配置类</h3><p>然后，你需要创建一个配置类，使用<code>@ComponentScan</code>来包含你的注解，并使用<code>@EventListener</code>来监听应用启动事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartupRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener(ApplicationReadyEvent.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runStartupMethods</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; beans = applicationContext.getBeansWithAnnotation(RunAtStartup.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object bean : beans.values()) &#123;</span><br><span class="line">            Method[] methods = bean.getClass().getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(RunAtStartup.class)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        method.invoke(bean);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置类中，<code>runStartupMethods</code> 方法会在Spring应用启动并准备好后被调用。它通过<code>ApplicationContext</code>查找所有标记了<code>@RunAtStartup</code>注解的Bean，然后反射调用这些Bean上标记了<code>@RunAtStartup</code>的方法。</p>
<h3 id="3-使用自定义注解"><a href="#3-使用自定义注解" class="headerlink" title="3. 使用自定义注解"></a>3. 使用自定义注解</h3><p>现在，你可以在任何Spring管理的Bean的方法上使用<code>@RunAtStartup</code>注解，这个方法将在应用启动时被自动调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RunAtStartup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myStartupMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The application is starting up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-启动应用"><a href="#4-启动应用" class="headerlink" title="4. 启动应用"></a>4. 启动应用</h3><p>当你启动Spring应用时，<code>MyService</code> 中的 <code>myStartupMethod</code> 方法将被自动调用，并输出日志信息。</p>
<p>这种方法利用了Spring的事件监听机制和反射，使得你可以在程序启动时执行特定的方法。你可以根据需要调整<code>StartupRunner</code>类，以适应更复杂的启动逻辑或执行更多的初始化任务。</p>

    </div>
</div>

<h2 id="1-8如何封装自定义组件，提供给其他项目使用"><a href="#1-8如何封装自定义组件，提供给其他项目使用" class="headerlink" title="1.8如何封装自定义组件，提供给其他项目使用"></a>1.8如何封装自定义组件，提供给其他项目使用</h2><p>写好代码，经过测试，打好jar包供其他项目引入</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        具体点
    </div>
    <div class='fold-content'>
        <p>封装自定义组件，无论是工具类还是需要被Spring管理的Bean，都可以按照以下步骤来实现，并提供给其他项目使用：</p>
<h3 id="1-创建组件"><a href="#1-创建组件" class="headerlink" title="1. 创建组件"></a>1. 创建组件</h3><p><strong>对于工具类</strong>：</p>
<ul>
<li>创建一个普通的Java类，包含静态方法或非静态工具方法。</li>
</ul>
<p><strong>对于需要管理的Bean</strong>：</p>
<ul>
<li>创建一个带有Spring注解（如<code>@Component</code>或<code>@Service</code>）的类，以便Spring容器可以管理它。</li>
</ul>
<h3 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2. 编写代码"></a>2. 编写代码</h3><ul>
<li>实现组件的功能逻辑。</li>
</ul>
<h3 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h3><ul>
<li>为组件编写单元测试，确保其功能正确。</li>
</ul>
<h3 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h3><ul>
<li>使用Maven或Gradle等构建工具将组件打包成JAR文件。</li>
</ul>
<h3 id="5-文档和JavaDoc"><a href="#5-文档和JavaDoc" class="headerlink" title="5. 文档和JavaDoc"></a>5. 文档和JavaDoc</h3><ul>
<li>编写使用文档和JavaDoc，以便其他开发者了解如何使用你的组件。</li>
</ul>
<h3 id="6-版本控制"><a href="#6-版本控制" class="headerlink" title="6. 版本控制"></a>6. 版本控制</h3><ul>
<li>使用Git等版本控制系统管理你的代码。</li>
</ul>
<h3 id="7-发布到仓库"><a href="#7-发布到仓库" class="headerlink" title="7. 发布到仓库"></a>7. 发布到仓库</h3><ul>
<li>将打包好的JAR文件发布到Maven中央仓库或其他私有仓库。</li>
</ul>
<h3 id="8-在其他项目中使用"><a href="#8-在其他项目中使用" class="headerlink" title="8. 在其他项目中使用"></a>8. 在其他项目中使用</h3><p><strong>对于工具类</strong>：</p>
<ul>
<li>在其他项目的代码中直接引用工具类。</li>
</ul>
<p><strong>对于需要管理的Bean</strong>：</p>
<ul>
<li>在其他项目的Spring配置中引入组件的依赖，并注册Bean。</li>
</ul>
<h3 id="9-Maven或Gradle配置"><a href="#9-Maven或Gradle配置" class="headerlink" title="9. Maven或Gradle配置"></a>9. Maven或Gradle配置</h3><p>在其他项目的<code>pom.xml</code>或<code>build.gradle</code>文件中添加依赖：</p>
<p><strong>Maven</strong> (<code>pom.xml</code>):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-component<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Gradle</strong> (<code>build.gradle</code>):</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.example:my-component:1.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-确保兼容性"><a href="#10-确保兼容性" class="headerlink" title="10. 确保兼容性"></a>10. 确保兼容性</h3><ul>
<li>确保你的组件在不同的环境中都能正常工作，考虑兼容性问题。</li>
</ul>
<h3 id="11-提供示例"><a href="#11-提供示例" class="headerlink" title="11. 提供示例"></a>11. 提供示例</h3><ul>
<li>提供使用示例，帮助其他开发者快速理解和使用你的组件。</li>
</ul>
<p>通过这些步骤，你可以将工具类或Spring管理的Bean封装成组件，并使其易于在其他项目中重用。记得在发布组件时遵循最佳实践，包括提供清晰的文档和维护良好的版本历史。</p>

    </div>
</div>

<h2 id="1-9怎么设计一个好的，优秀的系统"><a href="#1-9怎么设计一个好的，优秀的系统" class="headerlink" title="1.9怎么设计一个好的，优秀的系统"></a>1.9怎么设计一个好的，优秀的系统</h2><p>待研究</p>
<div class='fold collapsed'>
    <div class='fold-title'>
        可参考
    </div>
    <div class='fold-content'>
        <p>设计一个优秀系统是一个复杂的过程，涉及到多个方面的考量。以下是一些关键的步骤和原则，可以帮助你设计出高质量的系统：</p>
<ol>
<li><p><strong>明确需求</strong>：</p>
<ul>
<li>与利益相关者沟通，明确系统的目标、功能需求、性能要求和用户期望。</li>
</ul>
</li>
<li><p><strong>用户中心设计</strong>：</p>
<ul>
<li>以用户为中心，设计直观易用的用户界面和体验。</li>
</ul>
</li>
<li><p><strong>模块化</strong>：</p>
<ul>
<li>将系统分解为独立的模块，有助于维护和扩展。</li>
</ul>
</li>
<li><p><strong>可扩展性</strong>：</p>
<ul>
<li>设计时考虑未来可能的需求变化，确保系统可以容易地添加新功能。</li>
</ul>
</li>
<li><p><strong>可维护性</strong>：</p>
<ul>
<li>编写清晰、结构良好的代码，提供充足的文档和注释。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>确保系统在性能上满足要求，包括响应时间、处理能力和资源消耗。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>实施安全措施，保护系统免受攻击，并确保数据的安全和隐私。</li>
</ul>
</li>
<li><p><strong>可靠性和容错性</strong>：</p>
<ul>
<li>设计系统以处理故障和异常情况，确保系统的稳定性和可靠性。</li>
</ul>
</li>
<li><p><strong>测试</strong>：</p>
<ul>
<li>实施全面的测试策略，包括单元测试、集成测试和性能测试。</li>
</ul>
</li>
<li><p><strong>合规性</strong>：</p>
<ul>
<li>确保系统遵守相关法律法规和行业标准。</li>
</ul>
</li>
<li><p><strong>技术选型</strong>：</p>
<ul>
<li>选择合适的技术和工具，以支持系统的设计和实现。</li>
</ul>
</li>
<li><p><strong>持续集成和持续部署（CI&#x2F;CD）</strong>：</p>
<ul>
<li>采用CI&#x2F;CD实践，以自动化的方式频繁地交付和部署代码。</li>
</ul>
</li>
<li><p><strong>监控和日志</strong>：</p>
<ul>
<li>实施监控和日志记录，以便跟踪系统状态和及时发现问题。</li>
</ul>
</li>
<li><p><strong>灾难恢复计划</strong>：</p>
<ul>
<li>准备灾难恢复计划，以应对系统故障或数据丢失。</li>
</ul>
</li>
<li><p><strong>反馈机制</strong>：</p>
<ul>
<li>建立用户反馈机制，持续改进系统。</li>
</ul>
</li>
<li><p><strong>团队协作</strong>：</p>
<ul>
<li>促进团队成员之间的有效沟通和协作。</li>
</ul>
</li>
<li><p><strong>持续学习和改进</strong>：</p>
<ul>
<li>跟踪最新的技术趋势和最佳实践，不断学习和改进。</li>
</ul>
</li>
</ol>
<p>设计一个优秀的系统不仅仅是技术问题，还涉及到项目管理、团队合作和用户体验等多个方面。通过遵循上述原则，并持续迭代和改进，你可以设计出满足用户需求、性能优异且易于维护的系统。</p>

    </div>
</div>



<h2 id="1-10在构建员工工资发放系统时，应如何设计以满足每月10号准时发放工资的需求？"><a href="#1-10在构建员工工资发放系统时，应如何设计以满足每月10号准时发放工资的需求？" class="headerlink" title="1.10在构建员工工资发放系统时，应如何设计以满足每月10号准时发放工资的需求？"></a>1.10在构建员工工资发放系统时，应如何设计以满足每月10号准时发放工资的需求？</h2><p>问：下面给你一个场景，你作为一个主负责人，你会去怎么设计它？假设我们集团有三千多号人，那我们每个月10号要给每个人发工资。那财务会在每个月9号的时候，把这个工资表报表导入到系统，那你会去怎么设计这套系统？把报表导入到系统对，你要对接银行的接口，给每个人发工资。就说白了就是你现在写个程序给集团的员工发工资，那你为什么设计这个系统给其他员工发工资</p>
<p>为什么设计这样的系统：设计一套自动化的工资发放系统对于拥有三千多名员工的大型集团来说至关重要。这样的系统不仅可以提高效率、减少人为错误，还可以确保工资按时、准确地发放到每个员工的账户中。也就是为什么设计这个系统？</p>
<ul>
<li><strong>提高效率</strong>：自动化处理可以大幅减少手动操作的时间和劳动强度。</li>
<li><strong>减少错误</strong>：自动化系统可以减少人为错误，提高工资计算和发放的准确性。</li>
<li><strong>合规性</strong>：确保工资发放符合法律法规要求。</li>
<li><strong>透明度</strong>：提供清晰的工资发放记录，增加员工对工资发放流程的信任。</li>
<li><strong>成本效益</strong>：长期来看，自动化系统可以降低运营成本。</li>
</ul>
<h2 id="1-11发言人-问：您平时是如何进行学习的"><a href="#1-11发言人-问：您平时是如何进行学习的" class="headerlink" title="1.11发言人 问：您平时是如何进行学习的?"></a>1.11发言人 问：您平时是如何进行学习的?</h2><p>​    发言人答：我通常跟随学校课程学习，并利用课余时间自主探索自己感兴趣的内容，主要通过阅读书籍、观看视频以及查阅网络资料来获取知识。  </p>
<p>​     </p>
<p>​      </p>
<link rel="stylesheet" href="/Blog/css/folder.css" type="text/css"><script src="/Blog/js/folder.js" type="text/javascript" async></script>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kerisuchiaki.github.io/2024/09/02/%E6%98%93%E8%81%94%E4%BC%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" data-id="cm0nd7tt00000505bezj9g9lc" data-title="易联众面试总结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/Blog/2024/10/05/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          算法数论-质因数分解
        
      </div>
    </a>
  
  
    <a href="/Blog/2024/08/24/dfs%E6%B1%82%E5%85%A8%E6%8E%92%E5%88%97/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">dfs求全排列</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/BUG/" rel="tag">BUG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">java后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/java%E6%BA%90%E7%A0%81/" rel="tag">java源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/jvm/" rel="tag">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/leetcode%E9%A2%98%E8%A7%A3/" rel="tag">leetcode题解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/oracle/" rel="tag">oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/rabbitmq/" rel="tag">rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/springboot/" rel="tag">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E4%BD%9C%E4%B8%9A/" rel="tag">作业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E5%AE%9E%E9%AA%8C/" rel="tag">实验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E5%AE%9E%E9%AA%8C3/" rel="tag">实验3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E6%84%9F%E6%83%B3/" rel="tag">感想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E7%96%91%E9%97%AE/" rel="tag">疑问</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E7%AC%94%E8%AF%95/" rel="tag">笔试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" rel="tag">问题记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/Blog/tags/BUG/" style="font-size: 10px;">BUG</a> <a href="/Blog/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/Blog/tags/git/" style="font-size: 10px;">git</a> <a href="/Blog/tags/java/" style="font-size: 17.5px;">java</a> <a href="/Blog/tags/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 10px;">java后端开发</a> <a href="/Blog/tags/java%E6%BA%90%E7%A0%81/" style="font-size: 10px;">java源码</a> <a href="/Blog/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/Blog/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/Blog/tags/leetcode%E9%A2%98%E8%A7%A3/" style="font-size: 12.5px;">leetcode题解</a> <a href="/Blog/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/Blog/tags/rabbitmq/" style="font-size: 10px;">rabbitmq</a> <a href="/Blog/tags/redis/" style="font-size: 10px;">redis</a> <a href="/Blog/tags/shell/" style="font-size: 10px;">shell</a> <a href="/Blog/tags/spring/" style="font-size: 10px;">spring</a> <a href="/Blog/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/Blog/tags/test/" style="font-size: 10px;">test</a> <a href="/Blog/tags/%E4%BD%9C%E4%B8%9A/" style="font-size: 10px;">作业</a> <a href="/Blog/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 12.5px;">实验</a> <a href="/Blog/tags/%E5%AE%9E%E9%AA%8C3/" style="font-size: 10px;">实验3</a> <a href="/Blog/tags/%E6%84%9F%E6%83%B3/" style="font-size: 10px;">感想</a> <a href="/Blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构与算法</a> <a href="/Blog/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/Blog/tags/%E7%96%91%E9%97%AE/" style="font-size: 10px;">疑问</a> <a href="/Blog/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">笔记</a> <a href="/Blog/tags/%E7%AC%94%E8%AF%95/" style="font-size: 10px;">笔试</a> <a href="/Blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/Blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/Blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/Blog/tags/%E9%97%AE%E9%A2%98/" style="font-size: 10px;">问题</a> <a href="/Blog/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">问题记录</a> <a href="/Blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 20px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Blog/archives/2022/12/">December 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Blog/2025/02/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">多线程交替打印字符串问题记录</a>
          </li>
        
          <li>
            <a href="/Blog/2025/02/12/%E5%B0%9A%E4%B8%BA%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95/">尚为科技面试</a>
          </li>
        
          <li>
            <a href="/Blog/2025/02/12/%E8%BF%9C%E6%96%B9%E7%AB%A0%E9%B1%BC%E7%BD%91%E6%B4%9B%E9%9D%A2%E8%AF%95/">远方章鱼网洛面试</a>
          </li>
        
          <li>
            <a href="/Blog/2025/02/12/%E6%AD%A6%E6%B1%89%E7%99%BE%E5%9D%87%E5%9F%8E%E4%BA%8C%E9%9D%A2/">武汉百均城二面</a>
          </li>
        
          <li>
            <a href="/Blog/2024/12/19/%E6%B4%9E%E9%9A%90%E7%A7%91%E6%8A%80%E7%BB%88%E9%9D%A2/">洞隐科技终面</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 myself<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Blog/" class="mobile-nav-link">Home</a>
  
    <a href="/Blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/Blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/Blog/js/script.js"></script>





  </div>
</body>
</html>